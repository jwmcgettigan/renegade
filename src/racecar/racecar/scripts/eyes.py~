#!/usr/bin/env python
import rospy as rp
import functions as f
import controller as con
import cv2
#from threading import Thread
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from ackermann_msgs.msg import AckermannDriveStamped, AckermannDrive


bridge = CvBridge()
leftSlope = 0.0
rightSlope = 0.0

def frame_processor(image, side):
    hsv = f.hsv_color_selection(image)
    hsl = f.hsl_color_selection(image)
    color_select = hsv
    gray = f.gray_scale(color_select)
    smooth = f.gaussian_smoothing(gray)
    edges = f.canny_detector(smooth)
    # region = f.region_of_interest(edges)
    hough = f.hough_transform(edges)
    
    if side=='left':
        global leftSlope
        leftSlope = f.getSlope()

    if side=='right':
        global rightSlope
        rightSlope = f.getSlope()
    
    result = f.draw_lane_line(image, f.lane_line(image, hough))
    color_result = f.draw_lane_line(color_select, f.lane_line(color_select, hough))
    hough_lines = f.hough_lines(edges)
    # weighted_hough = cv2.addWeighted(image, 1.0, f.hough_lines(edges), 1.0, 0.0)
    return color_result


vesc = rp.Publisher("/vesc/high_level/ackermann_cmd_mux/input/nav_0", \
                      AckermannDriveStamped, queue_size=1)
#rp.Subscriber("eyes", Image, callback)
#last_error = None
#drive_thread = Thread(target=controller)
#drive_thread.start()

def callback(data):
    img = bridge.imgmsg_to_cv2(data, desired_encoding="passthrough")
    left_img = img[188:376, 0:672]
    right_img = img[188:376, 672:1344]

    cv2.imshow('Left Eye', frame_processor(left_img, 'left'))
    cv2.imshow('Right Eye', frame_processor(right_img, 'right'))
    controller()
    frame_processor(left_img, 'left')
    frame_processor(right_img, 'right')
    if cv2.waitKey(20) & 0xFF == ord('q'):
        pass


rp.Subscriber("eyes", Image, callback)


def controller():
    global leftSlope
    global rightSlope
    print "Left Slope: " + str(leftSlope) + ", Right Slope: " + str(rightSlope)
    print "Sum of Slopes: " + str(leftSlope + rightSlope)
    control = con.turn_control(leftSlope + rightSlope)
    print "Control: " + str(control)
    
    if f.getIsThereALine:
    	apply_control(1, control)
    else:
        apply_control(1, 0)


def apply_control(speed, steering_angle):
    drive_msg_stamped = AckermannDriveStamped()
    drive_msg = AckermannDrive()
    drive_msg.speed = speed
    drive_msg.steering_angle = steering_angle
    drive_msg.acceleration = 0
    drive_msg.jerk = 0
    drive_msg.steering_angle_velocity = 0
    drive_msg_stamped.drive = drive_msg
    vesc.publish(drive_msg_stamped)
    #rp.sleep(1.0 / 20)


def stop():
    drive_msg_stamped = AckermannDriveStamped()
    drive_msg = AckermannDrive()
    drive_msg.speed = 0
    drive_msg.steering_angle = 0
    drive_msg.acceleration = 0
    drive_msg.jerk = 0
    drive_msg.steering_angle_velocity = 0
    drive_msg_stamped.drive = drive_msg
    vesc.publish(drive_msg_stamped)


if __name__ == '__main__':
    rp.init_node("controller", anonymous=True)
    rp.spin()
    cv2.destroyAllWindows()
